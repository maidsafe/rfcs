# File Sharing By SAFE Address URL 

- Status: proposed
- Type: new feature
- Related components: SAFE Beaker Browser, safe-js, safe_core
- Start Date: 22-11-2016
- Discussion: (Preliminary to be replaced) - [File sharing at the level of safe: URLs](https://forum.safedev.org/t/file-sharing-at-the-level-of-safe-urls/288?u=happybeing) 
- Supersedes: n/a
- Superseded by: n/a


## Summary

Provide a way to obtain a `safe:` URL based on the SAFE network address for any file stored using SAFE NFS, and which does not rely on a public ID or the SAFE DNS. Such a *SAFE Address URL* would be valid to use as part of a normal HTML page or as a file download link in SAFE Beaker Browser. This avoids the need for a special file sharing app, or for the user to have made a public ID and service for the purpose of sharing files (see *Alternatives*). All that is needed is a way to generate a SAFE Address URL for a given file. It can then be downloaded using only a standard SAFE Browser, or accessed by any SAFE app. 

## Conventions
- The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119).


## Motivation

Allowing web applications and SAFE Beaker to access files directly using a SAFE Address URL would allow, for example:

- an image captured by a SAFE web app and stored in a user's SAFE NFS storage, to be loaded into the DOM of the app, or into an HTML document generated by the app, and displayed within by the browser as part of the app UI or saved HTML.

- a *Share file...* command, easily implemented in any app, which offers up a SAFE Address URL for a file saved to or chosen from NFS 'drive'. This URL can be sent to anyone who, provided the file is public, could then access the file with just a SAFE web browser.  Private files could also be accessed this way but only by the authorised owner, as part of their browser history, or as quick access links in other applications or documents.

Without this feature, the SAFE NFS user would need to use a specialist file sharing application to share a file, and files accessed through such links would be less secure, hard to trust or guarantee permanence.

Providing access to SAFE files without requiring publication via SAFE DNS, makes it easy to port existing apps, or for someone who already knows how to create and load files using traditional methods to offer this functionality in new apps. 

The ability to guaranteed permanence of download links will no doubt also lead to the creation of new and innovative kinds of application.

## Required Functionality

A way of identifying the file to be shared and obtaining a SAFE Address URL for it.

For SAFE Beaker Browser to recognise and process a SAFE Address URL differently from an ordinary `safe:` URL.


## Detailed design

We need a format of `safe:` URL which SAFE Beaker (and other compatible browsers) can recognise and use to access content stored on SAFE network without reference to a SAFE public ID. 

Each file stored on SAFE network is addressed using a [DataIdentifier](https://github.com/maidsafe/routing/blob/7c00dd14a2c4e4b2a3f7813a13edad119c0efa83/src/data/mod.rs#L111), so we can use that to address the file on the network. 

We must also consider different kinds of file and how to provide expected and appropriate behaviour, depending on how the file is stored (e.g. as immutable data, mutable data, key-value store etc.), how it is identified by the user (e.g. via a directory listing obtained from SAFE NFS), and the type of the file (e.g. text, PDF, HTML, binary, video etc.).

### SAFE Web URL Structure

To recap existing functionality, a `safe:` website URL is similar to a standard web URL, but always begins with `safe` rather than `http` or `https`. This link protocol indicates the resource is to be located on the SAFE network. For a website published on SAFE network, we create a public ID and service using SAFE NFS, and this allows SAFE Beaker to interpret URLs of the following form:

	`safe://[service.]publicid[/filepath]`

`service` is optional, and defaults to `www`

`filepath` is also optional, and if service is ommitted or given as `www`, the filepath defaults to `index.html`

NOTE: In the above and subsequent notation, square brackets denote an optional component. So `[service.]publicid` means either a value which equates to a `service` followed by a '.' followed by a value for a `publicid`, or just a value for a `publicid`. So for example, the following URLs would all access the same file assuming it exists in a directory that has been published at the given service and public ID:

	`safe://rfcs`
	`safe://www.rfcs`
	`safe://rfcs/index.html`
	`safe://www.rfcs/index.html`

All the above is existing functionality, so the format of *SAFE Address URLs* must always be distinguishable from this.

### SAFE Address URL Structure

SAFE Beaker must be able to recognise a SAFE Address URL, parse it, and determine what method to use to access the file, and what if any meta data to provide with the response it delivers. We can also choose to provide a way for a human readable filename to be conveyed as part of the URL, rather than base this on the address or having the user type it in.

**A SAFE Address URL always begins with `safe:<type>:`** This allows us to continue to permit a normal `safe:` URL to omit or include the conventional but redundant '//' that we are accustomed to in web URLs.

The complete structure of a SAFE Address URL is then:

	`safe:type:address[:filename]`

Where:

- `type` is one of `file:` or `folder:` or `dns:`. So far I have only discussed retrieving regular files stored with SAFE NFS, but including a type instructs the client on the type of data being retrieved access and how to make use of it, while providing for support to added later for additional types, with backwards compatibility.

- `address` is the a base64 encoded serialisation of a [DataIdentifier](https://github.com/maidsafe/routing/blob/7c00dd14a2c4e4b2a3f7813a13edad119c0efa83/src/data/mod.rs#L111).

- `filename` is the URI encoded value of a string that must not include the path separator character '/' (i.e it is a filename without a path, and with an optional file extension).

Examples might be:

	`safe:file:U2VjdXJlIEFjY2VzcyBGb3IgRXZlcnlvbmU=:happybeing.png`
	`safe:file:U2VjdXJlIEFjY2VzcyBGb3IgRXZlcnlvbmU=:Safecoin-white-paper.pdf`
	`safe:file:U2VjdXJlIEFjY2VzcyBGb3IgRXZlcnlvbmU=`


This RFC does not consider the details or use of `folder:` or `dns:` or other types as these can be defined later. For now we only need implement type `file:`

The author believes that this method of addressing SAFE NFS stored files will be feasible according to [RFC0046-new-auth-flow](https://github.com/maidsafe/rfcs/tree/master/text/0046-new-auth-flow) which uses a system of [Containers](https://github.com/maidsafe/rfcs/blob/master/text/0046-new-auth-flow/containers.md#nfs-convention) to emulate file system at the NFS level. 

This though will depend on the decisions taken around implementing emulation NFS and the underlying NFS file structures. 

**Permanent URLs:** SAFE NFS files are immutable data, so a SAFE Address URL will by default be a permanent link to immutable data.

#### Extensibility
This URL scheme is simple and retains the potential to be extended to provide for additional data types, and to control their retrieval and interpretation.

For example, values within a key-value store (in a MutableData object) could be addressed directly by extending the Address URL with parameters. So for a given application, appending `?key=postaladdress&encoding=json` to a URL could be used to retrieve the value of `name` from a MutableData object and parse it ready for use.

### Behaviour Options - Discussion

Assuming the shared file is immutable, we can guarantee that the SAFE Address URL will also be permanent. If the file were either mutable or deliberately referenced via a mutable data structure, then the URL could be impermanent by design. So disregarding at this stage any limitations imposed by the implementation, we should in reviewing this RFC consider the viability and usefulness of designing SAFE Address URLs to be *either* permanent or impermanent.

**IMPORTANT:** At this point both options are on the table so we can debate what is expected and desirable, but as is stands this RFC proposes to implement only permanent SAFE Address URLs. Some points for discussion are presented below.

#### Permanent URLs

If all SAFE Address URLs are valid forever, we have the advantage of certainty, and the feature of permanent access to all files shared in this manner.

It wouldn't ensure that SAFE websites were always available forever and immutable, because generally these utilise ordinary SAFE URLs that map to a mutable file structure, but the advent of *Permanent URLs* would make it *possible* to create a SAFE web app or website that could be inspected to verify it as permanent and immutable.

The question is whether we would want to limit SAFE Address URLs to only allow sharing of immutable data, or to allow permanent *and* impermanent URLs (see next). A guarantee of permanence for all SAFE Address URLs would have to be verifiable (i.e. within safe_core), because it would not be desirable for people to assume that these were permanent and immutable if there was a way of subverting this with a customised SAFE Address URL maker).

#### Impermanent URLs

There are many good things about permanent URLs, but also the disadvantage for users who accidentally share something that can never subsequently be unshared. There are also things people want to be able to share temporarily. For example, in order that the intended recipient access them, but later be invalidated to reduce the chance that someone else who discovers the URL can gain access to the file.  

In general, what one shares one day, or in one state of mind, might later be regretted and so in certain circumstances it might also be useful to provide a way to generate URLs that can be invalidated. Impermanence is also likely to be expected behaviour, so if it is not, we might need to find ways to make that very clear. 

On the other hand, applications could be developed to extend file sharing to allow the creation of deletable URLs if this is seen as desired, which also helps make it clear that the default is permanence.

If we create built-in support for *both* permanent and impermanent URLs it would be sensible to indicate this as part of the URL so that users know what they are sharing and receiving. For example, by adding '-p' or '-i' to the end of the `type` as in:

	`safe:file-p:U2VjdXJlIEFjY2VzcyBGb3IgRXZlcnlvbmU=:Safecoin-white-paper.pdf`

Adding support for impermanent URLs would require a *delete SAFE Address URL* API, which raises a further question as to whether or not we should allow different files to appear at the same address at different times, and if not then how this could be prevented. It would mean that SAFE Address URLs could not always be guaranteed to be permanent, which might be undesirable. It also creates a problem for anyone in possession of a SAFE Address URL: how to tell if it is permanent or not.

**IMPORTANT:** For simplicity's sake, this RFC mandates only permanent URLs (so only type `file:` and never `file-p:` or `file-i:`) which means that with this proposal we can always guarantee SAFE Address URLs are permanent, and we can leave the tricky questions for a later upgrade discussion.

### SAFE NFS API Changes

Assuming only *permanent SAFE Address URLs* are supported, SAFE NFS API to be extended with:

	`getPermanentLink(fileName: String) -> Future<String>` 

	`fileName`	- the full path of an existing file in the user's NFS storage

This returns a permanently valid URL for fileName formatted as a SAFE Address URL including `type`, `address` and `filename` elements.

If we later support impermanent URLs a suitably named function can be added which would use a type of `file-i` instead of `file`

### safe-js Changes

safe-js to be extended with `safeNFS.getPermanentLink()` which returns a Promise that resolves to a SAFE Address URL as above.

### SAFE Beaker Changes

SAFE Beaker will detect every SAFE Address URL, parse it according to the above, and use this information to:

a) access the file on the network

b) provide error handling where retrieving the file fails or times out

c) deliver the content appropriately (e.g. embedded in HTML content, embedded download link, or location bar access) including where provided: applying metadata to assist in rendering embedded content, and supplying a default filename when offering to download. 


## Drawbacks

Relying on the implementation of SAFE NFS storage means this functionality would be difficult to maintain if that ever changes.

There might be privacy or tracking issues associated with sharing URLs if they could somehow be linked back to a user or account, though none are immediately apparent, except for ill considered naming of files.


## Alternatives

Not doing this would require users to find other ways of sharing files, which since they are not built in to safe_core and SAFE Beaker will be more cumbersome (for users and for app developers), impossible to ensure permanence, and harder to trust in terms of security (i.e. from tracking and surveillance). Making such a widely used feature harder than necessary would reduce the rate and potential level of adoption, thereby diminishing its positive overall impact on security and privacy.

Alternatives would probably consume more network resources than providing support for direct links within safe_core, increasing user PUT costs and network load for a feature we can expect would be used by almost every SAFE user.

### Application based or shared DNS

Rather than addressing a file using a network address, we might use either the existing SAFE DNS to share files saved in the user or application managed public storage. SAFE NFS at present would be cumbersome to use for this, requiring every app which wants to generate file URLs to have access to a user's registered public ID and service so this is not practical.

There are changes being considered which may make a DNS based sharing URLs more practical (see [this dev forum post](https://forum.safedev.org/t/file-sharing-at-the-level-of-safe-urls/288/7?u=happybeing)) but these have not been decided and have not been considered as part of this RFC. Once clear, it may be worthwhile reviewing this option.	


## Unresolved questions

It needs to be confirmed that proposed modifications to the implementation of SAFE NFS [Containers](https://github.com/maidsafe/rfcs/blob/master/text/0046-new-auth-flow/containers.md#nfs-convention) would support this functionality if adopted.